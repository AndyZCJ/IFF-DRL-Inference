{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "import torch\n",
    "import torch.nn as nn\n",
    "import torch.nn.functional as F\n",
    "import torch.optim as optim\n",
    "import random\n",
    "import talib\n",
    "import math\n",
    "from datetime import datetime\n",
    "from tabulate import tabulate"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "def setup_seed(seed):\n",
    "    torch.manual_seed(seed)\n",
    "    torch.cuda.manual_seed_all(seed)\n",
    "    np.random.seed(seed)\n",
    "    random.seed(seed)\n",
    "    torch.backends.cudnn.deterministic = True\n",
    "# 设置随机数种子\n",
    "setup_seed(1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "file_path = './DJI.csv'\n",
    "df = pd.read_csv(file_path)\n",
    "df = df.dropna()\n",
    "train_startingDate = datetime.strptime('2007-01-01', '%Y-%m-%d')\n",
    "train_endingDate = datetime.strptime('2017-12-31', '%Y-%m-%d') \n",
    "test_startingDate = datetime.strptime('2018-01-01', '%Y-%m-%d') \n",
    "test_endingDate = datetime.strptime('2020-12-31', '%Y-%m-%d') "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Dataprocessor:\n",
    "    def preProcessor(self,df, start_date='2007-01-01', end_date='2017-12-31'):\n",
    "        preprocessed_data = []\n",
    "        df = df.drop(['Adj Close'], axis=1)\n",
    "        df = df[-df.Volume.isin([0])]\n",
    "    #     print(\"Volume\",security.head())\n",
    "        df['Open'] = df['Open'].values.astype(float)\n",
    "        df['Close'] = df['Close'].values.astype(float)\n",
    "        df['Low'] = df['Low'].values.astype(float)\n",
    "        df['High'] = df['High'].values.astype(float)\n",
    "        df['Volume'] = df['Volume'].values.astype(float)\n",
    "        df['Date'] = pd.to_datetime(df['Date'])\n",
    "        df = df.loc[(df['Date'] >= start_date) & (df['Date'] <= end_date)]\n",
    "        day_df = df\n",
    "        day_df.reset_index(drop = True,inplace = True)\n",
    "        day_df = day_df.drop(['Price'], axis=1)\n",
    "        trend = df[['Date','Close']]\n",
    "        return day_df, trend"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "class TradingEnv:\n",
    "    def __init__(self, df, startingDate, endingDate, init_money=500000):\n",
    "        self.n_actions = 3 # 动作数量\n",
    "        self.window_size = 100 #mark 150->100\n",
    "        self.init_money = init_money # 初始化资金\n",
    "        self.seq_len = 20 #mark 30->20\n",
    "        self.input_size = 5\n",
    "        self.startingDate = startingDate\n",
    "        self.endingDate = endingDate\n",
    "        self.data = df\n",
    "        self.data['Price'] = self.data['Close']\n",
    "\n",
    "    def init_market_data(self):\n",
    "        dataprocessor = Dataprocessor()\n",
    "        day_df, trend = dataprocessor.preProcessor(self.data, self.startingDate, self.endingDate)\n",
    "        self.preprocessed_day_data = day_df   #[[\"Open\", \"High\", \"Low\", \"Close\", \"Volume\"]]\n",
    "        self.trend =  trend['Close']\n",
    "        self.account = trend\n",
    "        self.input_size = 5  # 特征数量\n",
    "        self.terminal_date = len(self.trend)-self.window_size\n",
    "#         print(\"day_df\",day_df,week_df)\n",
    "        \n",
    "\n",
    "    def reset(self, startingPoint=1):\n",
    "        self.t = np.clip(startingPoint, self.window_size-1, self.terminal_date-self.window_size)\n",
    "        self.account['Position'] = 0  # 0 : 空仓  1 : 多单  -1 : 空单\n",
    "        self.account['Action'] = 0    # 0 : 持有  1 : 开多单  -1 : 开空单  2 : 平仓\n",
    "        self.account['Q_Action'] = 0  # 网络给出的action， 0 : hold  1 : buy  -1 : sell\n",
    "        self.account['Holdings'] = 0 # 持仓市值\n",
    "        self.account['Cash'] = float(self.init_money) # 现金\n",
    "        self.account['Capitals'] = self.account['Holdings'] + self.account['Cash'] # 总市值\n",
    "        self.account['Returns'] = 0 # 每日盈亏\n",
    "        self.holdingNum = 0 # 持股量\n",
    "        self.transitionCost = 0.0001\n",
    "        self.account['NDC'] = 0   # 下一天波动作为reward\n",
    "        self.account['N5SR'] = 0  # 后五天的SR作为reward\n",
    "        self.long_pos = False # 是否持有多单\n",
    "        self.short_pos = False # 是否持有空单\n",
    "        self.last_value = self.init_money # 上一天市值\n",
    "        self.reward = 0 # 收益\n",
    "        self.states_sell = [] #卖股票时间\n",
    "        self.states_buy = [] #买股票时间\n",
    "        self.states_close = []#平仓时间\n",
    "        self.profit_rate_account = [] # 账号盈利\n",
    "        self.profit_rate_stock = [] # 股票波动情况\n",
    "        self.daily_return = [] # 每日盈亏比例\n",
    "        self.winning_trades = 0\n",
    "        self.total_trades = 0\n",
    "        self.last_opening_price = 0 # 开仓价\n",
    "        self.trade_profit = []      # 单笔盈亏\n",
    "        self.enddate = self.terminal_date\n",
    "        return self.get_state(self.t)\n",
    "\n",
    "    def get_state(self, t): #某t时刻的状态\n",
    "        day_all_data = self.preprocessed_day_data.iloc[t + 1 - self.window_size:t+1,:]\n",
    "        #mark 30->20\n",
    "        day_data = day_all_data.tail(20)\n",
    "        day_data.reset_index(drop = True,inplace = True)\n",
    "        day = day_data.drop(['Date'], axis=1)\n",
    "#         print(\"day_data\",day)\n",
    "\n",
    "        \n",
    "        day_state = (day - np.mean(day))/ (np.std(day)+0.0001)\n",
    "        input_data = day_state.reset_index(drop=True)\n",
    "#         print(\"input_data\",input_data)\n",
    "        input_state = np.array(input_data) \n",
    "#         print(\"input_state\",input_state)\n",
    "        return np.ravel(input_state)\n",
    "\n",
    "    def buy_stock(self, show_log=False):\n",
    "        daily_chg=0\n",
    "        if len(self.profit_rate_account)==0:\n",
    "            last_value=0\n",
    "        else:\n",
    "            last_value = self.profit_rate_account[-1]\n",
    "        t = self.t\n",
    "#         print(\"t\",self.t)\n",
    "        if self.account.loc[t-1,'Position'] == -1:  # 有空单 -> 平仓\n",
    "            daily_chg = (self.trend[self.t-1] - self.trend[self.t])/self.trend[self.t-1]\n",
    "            profit_rate = (last_value+1)*daily_chg + last_value\n",
    "            self.states_close.append(self.t)\n",
    "            self.short_pos=False\n",
    "            self.account.loc[t, 'Cash'] = self.account.loc[t-1, 'Cash'] - self.holdingNum*self.account.loc[t, 'Close']*(1+self.transitionCost)\n",
    "            self.account.loc[t, 'Position'] = 0\n",
    "            self.account.loc[t, 'Action'] = 2\n",
    "            self.holdingNum = 0\n",
    "            self.trade_profit.append(self.last_opening_price-self.trend[self.t])\n",
    "\n",
    "            if show_log:\n",
    "                print('day:%d, close_short_pos price:%f' % (self.t, self.trend[self.t]))\n",
    "        elif self.account.loc[t-1,'Position'] == 0: # 空仓 -> 多单\n",
    "            self.states_buy.append(self.t)\n",
    "            # 计算买股量\n",
    "            self.holdingNum = math.floor(self.account.loc[t-1, 'Cash']/(self.account.loc[t, 'Close']*(1+self.transitionCost)))\n",
    "            # 计算现金变动\n",
    "            self.account.loc[t, 'Cash'] = self.account.loc[t-1, 'Cash']-self.holdingNum*self.account.loc[t, 'Close']*(1+self.transitionCost)\n",
    "            self.account.loc[t, 'Position'] = 1\n",
    "            self.account.loc[t, 'Action'] = 1\n",
    "            profit_rate = last_value\n",
    "            self.last_opening_price = self.trend[self.t]\n",
    "            if show_log:\n",
    "                print('day:%d, long_pos price:%f' % (self.t, self.trend[self.t]))\n",
    "        else :  # 无空单且有多单不操作\n",
    "            self.account.loc[t, 'Cash'] = self.account.loc[t-1, 'Cash']\n",
    "            self.account.loc[t, 'Position'] = self.account.loc[t-1, 'Position']\n",
    "            self.account.loc[t, 'Action'] = 0\n",
    "            daily_chg = (self.trend[self.t] - self.trend[self.t-1])/self.trend[self.t-1]\n",
    "            profit_rate = (last_value+1)*daily_chg + last_value\n",
    "\n",
    "        self.daily_return.append(daily_chg)\n",
    "        self.profit_rate_account.append(profit_rate)\n",
    "\n",
    "\n",
    "    def sell_stock(self, show_log=False):\n",
    "        daily_chg=0\n",
    "        if len(self.profit_rate_account)==0:\n",
    "            last_value=0\n",
    "        else:\n",
    "            last_value = self.profit_rate_account[-1]\n",
    "        t = self.t\n",
    "        if self.account.loc[t-1, 'Position'] == 1:    # 有多单 -> 无持仓\n",
    "            daily_chg = (self.trend[self.t] - self.trend[self.t-1])/self.trend[self.t-1]\n",
    "            profit_rate = (last_value+1)*daily_chg + last_value\n",
    "            self.states_close.append(self.t)\n",
    "            self.account.loc[t, 'Cash'] = self.account.loc[t-1, 'Cash'] + self.holdingNum*self.account.loc[t, 'Close']*(1+self.transitionCost)\n",
    "            self.holdingNum = 0\n",
    "            self.account.loc[t, 'Position'] = 0\n",
    "            self.account.loc[t, 'Action'] = 2\n",
    "            self.trade_profit.append(self.trend[self.t]-self.last_opening_price)\n",
    "            if show_log:\n",
    "                print('day:%d, close_long_pos price:%f' % (self.t, self.trend[self.t]))\n",
    "        elif self.account.loc[t-1, 'Position'] == 0: # 无多单且无空单就开空单\n",
    "            self.states_sell.append(self.t)\n",
    "            self.holdingNum = math.floor(self.account.loc[t-1, 'Cash']/(self.account.loc[t, 'Close']*(1+self.transitionCost)))\n",
    "            self.account.loc[t, 'Cash'] = self.account.loc[t-1, 'Cash'] + self.holdingNum*self.account.loc[t, 'Close']*(1-self.transitionCost)\n",
    "            self.account.loc[t, 'Action'] = -1\n",
    "            self.account.loc[t, 'Position'] = -1\n",
    "            profit_rate = last_value\n",
    "            self.last_opening_price = self.trend[self.t]\n",
    "            if show_log:\n",
    "                print('day:%d, short_pos price:%f' % (self.t, self.trend[self.t]))\n",
    "        else : # 无多单且有空单不操作\n",
    "            self.account.loc[t, 'Cash'] = self.account.loc[t-1, 'Cash']\n",
    "            self.account.loc[t, 'Action'] = 0\n",
    "            self.account.loc[t, 'Position'] = self.account.loc[t-1, 'Position']\n",
    "            daily_chg = (self.trend[self.t-1] - self.trend[self.t])/self.trend[self.t-1]\n",
    "            profit_rate = (last_value+1)*daily_chg + last_value\n",
    "\n",
    "        self.daily_return.append(daily_chg)\n",
    "        self.profit_rate_account.append(profit_rate)\n",
    "\n",
    "    def risk_control(self, cur_price, show_log):\n",
    "        t = self.t\n",
    "        if len(self.profit_rate_account)==0:\n",
    "            last_value=0\n",
    "        else:\n",
    "            last_value = self.profit_rate_account[-1]\n",
    "        if self.account.loc[t-1, 'Position']==1:\n",
    "            profit_rate = (self.trend[self.t] - self.trend[self.t-1])/self.trend[self.t-1]\n",
    "            profit_rate = (last_value+1)*profit_rate + last_value\n",
    "        elif self.account.loc[t-1, 'Position']==-1:\n",
    "            profit_rate = (self.trend[self.t-1] - self.trend[self.t])/self.trend[self.t-1]\n",
    "            profit_rate = (last_value+1)*profit_rate + last_value\n",
    "        else :\n",
    "            profit_rate = last_value\n",
    "\n",
    "        self.account.loc[t, 'Cash'] = self.account.loc[t-1, 'Cash']\n",
    "        self.account.loc[t, 'Action'] = 0\n",
    "        self.account.loc[t, 'Position'] = self.account.loc[t-1, 'Position']\n",
    "        self.profit_rate_account.append(profit_rate)\n",
    "\n",
    "    def step(self, action, show_log=False):\n",
    "        if action == 1 and self.t < (len(self.trend)-1):\n",
    "            self.account.loc[self.t, 'Q_Action'] = 1\n",
    "            self.buy_stock(show_log)\n",
    "        elif action == 2 and self.t < (len(self.trend)-1):\n",
    "            self.account.loc[self.t, 'Q_Action'] = -1\n",
    "            self.sell_stock(show_log)\n",
    "        elif action == 0 and self.t < (len(self.trend)-1): # 不操作\n",
    "            self.account.loc[self.t, 'Q_Action'] = 0\n",
    "            self.risk_control(self.trend[self.t], show_log)\n",
    "\n",
    "        # 夏普比率作为reward\n",
    "        chg = []\n",
    "        for i in range(5):\n",
    "            chg.append((self.trend[self.t + i + 1] - self.trend[self.t])/self.trend[self.t])\n",
    "        reward = np.mean(chg)/np.std(chg)\n",
    "\n",
    "        if self.account.loc[self.t, 'Position']==1:\n",
    "            self.reward = reward\n",
    "        elif self.account.loc[self.t, 'Position']==-1:\n",
    "            self.reward = -reward\n",
    "        else:\n",
    "            self.reward = 0\n",
    "        self.account.loc[self.t, 'N5SR'] = self.reward\n",
    "        self.account.loc[self.t, 'Holdings'] = self.account.loc[self.t, 'Position']*self.holdingNum*self.account.loc[self.t, 'Close']\n",
    "        self.account.loc[self.t, 'Capitals'] = self.account.loc[self.t, 'Cash'] + self.account.loc[self.t, 'Holdings']\n",
    "        self.account.loc[self.t, 'Returns'] = (self.account.loc[self.t, 'Capitals']-self.account.loc[self.t-1, 'Capitals'])/self.account.loc[self.t-1, 'Capitals']\n",
    "        self.profit_rate_stock.append((self.trend[self.t] - self.trend[0]) / self.trend[0])\n",
    "        done = False\n",
    "        self.t = self.t + 1\n",
    "        if self.t == self.enddate:\n",
    "            done = True\n",
    "            self.account = self.account.drop(index=(self.account.loc[(self.account.index>=self.t)].index))\n",
    "            self.total_trades = len(self.trade_profit)\n",
    "            self.winning_trades = len([i for i in self.trade_profit if i > 0])\n",
    "        s_ = self.get_state(self.t)\n",
    "        return s_, self.reward, done"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 36,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Inception_Block_V1(nn.Module):\n",
    "    def __init__(self, in_channels, out_channels, num_kernels=6, init_weight=True):\n",
    "        super(Inception_Block_V1, self).__init__()\n",
    "        self.in_channels = in_channels\n",
    "        self.out_channels = out_channels\n",
    "        self.num_kernels = num_kernels\n",
    "        kernels = []\n",
    "        for i in range(self.num_kernels):\n",
    "            kernels.append(nn.Conv2d(in_channels, out_channels, kernel_size=2 * i + 1, padding=i))\n",
    "        self.kernels = nn.ModuleList(kernels)\n",
    "        if init_weight:\n",
    "            self._initialize_weights()\n",
    "\n",
    "    def _initialize_weights(self):\n",
    "        for m in self.modules():\n",
    "            if isinstance(m, nn.Conv2d):\n",
    "                nn.init.kaiming_normal_(m.weight, mode='fan_out', nonlinearity='relu')\n",
    "                if m.bias is not None:\n",
    "                    nn.init.constant_(m.bias, 0)\n",
    "\n",
    "    def forward(self, x):\n",
    "        res_list = []\n",
    "        for i in range(self.num_kernels):\n",
    "            res_list.append(self.kernels[i](x))\n",
    "        res = torch.stack(res_list, dim=-1).mean(-1)\n",
    "        return res\n",
    "    \n",
    "class TokenEmbedding(nn.Module):\n",
    "    def __init__(self, c_in, d_model):\n",
    "        super(TokenEmbedding, self).__init__()\n",
    "        padding = 1 if torch.__version__ >= '1.5.0' else 2\n",
    "        self.tokenConv = nn.Conv1d(in_channels=c_in, out_channels=d_model,\n",
    "                                   kernel_size=3, padding=padding, padding_mode='circular', bias=False)\n",
    "        for m in self.modules():\n",
    "            if isinstance(m, nn.Conv1d):\n",
    "                nn.init.kaiming_normal_(\n",
    "                    m.weight, mode='fan_in', nonlinearity='leaky_relu')\n",
    "\n",
    "    def forward(self, x):\n",
    "        x = self.tokenConv(x.permute(0, 2, 1)).transpose(1, 2)\n",
    "        return x\n",
    "    \n",
    "class PositionalEmbedding(nn.Module):\n",
    "    def __init__(self, d_model, max_len=5000):\n",
    "        super(PositionalEmbedding, self).__init__()\n",
    "        # Compute the positional encodings once in log space.\n",
    "        pe = torch.zeros(max_len, d_model).float()\n",
    "        pe.require_grad = False\n",
    "\n",
    "        position = torch.arange(0, max_len).float().unsqueeze(1)\n",
    "        div_term = (torch.arange(0, d_model, 2).float()\n",
    "                    * -(math.log(10000.0) / d_model)).exp()\n",
    "\n",
    "        pe[:, 0::2] = torch.sin(position * div_term)\n",
    "        pe[:, 1::2] = torch.cos(position * div_term)\n",
    "\n",
    "        pe = pe.unsqueeze(0)\n",
    "        self.register_buffer('pe', pe)\n",
    "\n",
    "    def forward(self, x):\n",
    "        return self.pe[:, :x.size(1)]\n",
    "class TemporalEmbedding(nn.Module):\n",
    "    def __init__(self, d_model, embed_type='fixed', freq='h'):\n",
    "        super(TemporalEmbedding, self).__init__()\n",
    "\n",
    "        minute_size = 4\n",
    "        hour_size = 24\n",
    "        weekday_size = 7\n",
    "        day_size = 32\n",
    "        month_size = 13\n",
    "\n",
    "        Embed = FixedEmbedding if embed_type == 'fixed' else nn.Embedding\n",
    "        if freq == 't':\n",
    "            self.minute_embed = Embed(minute_size, d_model)\n",
    "        self.hour_embed = Embed(hour_size, d_model)\n",
    "        self.weekday_embed = Embed(weekday_size, d_model)\n",
    "        self.day_embed = Embed(day_size, d_model)\n",
    "        self.month_embed = Embed(month_size, d_model)\n",
    "\n",
    "    def forward(self, x):\n",
    "        x = x.long()\n",
    "        minute_x = self.minute_embed(x[:, :, 4]) if hasattr(\n",
    "            self, 'minute_embed') else 0.\n",
    "        hour_x = self.hour_embed(x[:, :, 3])\n",
    "        weekday_x = self.weekday_embed(x[:, :, 2])\n",
    "        day_x = self.day_embed(x[:, :, 1])\n",
    "        month_x = self.month_embed(x[:, :, 0])\n",
    "\n",
    "        return hour_x + weekday_x + day_x + month_x + minute_x\n",
    "    \n",
    "class TimeFeatureEmbedding(nn.Module):\n",
    "    def __init__(self, d_model, embed_type='timeF', freq='h'):\n",
    "        super(TimeFeatureEmbedding, self).__init__()\n",
    "\n",
    "        freq_map = {'h': 4, 't': 5, 's': 6,\n",
    "                    'm': 1, 'a': 1, 'w': 2, 'd': 3, 'b': 3}\n",
    "        d_inp = freq_map[freq]\n",
    "        self.embed = nn.Linear(d_inp, d_model, bias=False)\n",
    "\n",
    "    def forward(self, x):\n",
    "        return self.embed(x)\n",
    "\n",
    "class DataEmbedding(nn.Module):\n",
    "    def __init__(self, c_in, d_model, embed_type='fixed', freq='h', dropout=0.1):\n",
    "        super(DataEmbedding, self).__init__()\n",
    "\n",
    "        self.value_embedding = TokenEmbedding(c_in=c_in, d_model=d_model)\n",
    "        self.position_embedding = PositionalEmbedding(d_model=d_model)\n",
    "        self.temporal_embedding = TemporalEmbedding(d_model=d_model, embed_type=embed_type,\n",
    "                                                    freq=freq) if embed_type != 'timeF' else TimeFeatureEmbedding(\n",
    "            d_model=d_model, embed_type=embed_type, freq=freq)\n",
    "        self.dropout = nn.Dropout(p=dropout)\n",
    "    def forward(self, x, x_mark):\n",
    "        if x_mark is None:\n",
    "            x = self.value_embedding(x) + self.position_embedding(x)\n",
    "        else:\n",
    "            x = self.value_embedding(\n",
    "                x) + self.temporal_embedding(x_mark) + self.position_embedding(x)\n",
    "        return self.dropout(x)\n",
    "import numpy.polynomial.chebyshev as cheb\n",
    "def chebyshev_coefficients(x, degree):\n",
    "    if not np.any(x):\n",
    "        return x.flatten()\n",
    "    scaled_x = 2 * (x - np.min(x)) / (np.max(x) - np.min(x)+0.0000001) - 1\n",
    "    coefficients = [cheb.chebfit(scaled_x.flatten(), x.flatten(), i).mean() for i in range(degree + 1)]\n",
    "    return coefficients"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 37,
   "metadata": {},
   "outputs": [],
   "source": [
    "import argparse\n",
    "parser = argparse.ArgumentParser(description='TimesNet')\n",
    "\n",
    "# basic config\n",
    "parser.add_argument('--task_name', type=str, default='classification',\n",
    "                    help='task name, options:[long_term_forecast, short_term_forecast, imputation, classification, anomaly_detection]')\n",
    "\n",
    "\n",
    "\n",
    "# data loader\n",
    "parser.add_argument('--root_path', type=str, default='.all_datasets/ETT', help='root path of the data file')\n",
    "parser.add_argument('--data_path', type=str, default='ETTh1.csv', help='data file')\n",
    "parser.add_argument('--features', type=str, default='M',\n",
    "                    help='forecasting task, options:[M, S, MS]; M:multivariate predict multivariate, S:univariate predict univariate, MS:multivariate predict univariate')\n",
    "parser.add_argument('--target', type=str, default='OT', help='target feature in S or MS task')\n",
    "parser.add_argument('--freq', type=str, default='h',\n",
    "                    help='freq for time features encoding, options:[s:secondly, t:minutely, h:hourly, d:daily, b:business days, w:weekly, m:monthly], you can also use more detailed freq like 15min or 3h')\n",
    "parser.add_argument('--checkpoints', type=str, default='./checkpoints/', help='location of model checkpoints')\n",
    "\n",
    "# forecasting task\n",
    "parser.add_argument('--seq_len', type=int, default=96, help='input sequence length')\n",
    "parser.add_argument('--label_len', type=int, default=48, help='start token length')\n",
    "parser.add_argument('--pred_len', type=int, default=96, help='prediction sequence length')\n",
    "parser.add_argument('--seasonal_patterns', type=str, default='Monthly', help='subset for M4')\n",
    "\n",
    "# inputation task\n",
    "parser.add_argument('--mask_rate', type=float, default=0.25, help='mask ratio')\n",
    "\n",
    "# anomaly detection task\n",
    "parser.add_argument('--anomaly_ratio', type=float, default=0.25, help='prior anomaly ratio (%)')\n",
    "\n",
    "# model define\n",
    "parser.add_argument('--top_k', type=int, default=3, help='for TimesBlock')\n",
    "parser.add_argument('--num_kernels', type=int, default=6, help='for Inception')\n",
    "parser.add_argument('--enc_in', type=int, default=7, help='encoder input size')\n",
    "parser.add_argument('--dec_in', type=int, default=7, help='decoder input size')\n",
    "parser.add_argument('--c_out', type=int, default=7, help='output size')\n",
    "parser.add_argument('--d_model', type=int, default=32, help='dimension of model')\n",
    "parser.add_argument('--n_heads', type=int, default=8, help='num of heads')\n",
    "parser.add_argument('--e_layers', type=int, default=3, help='num of encoder layers')\n",
    "parser.add_argument('--d_layers', type=int, default=1, help='num of decoder layers')\n",
    "parser.add_argument('--d_ff', type=int, default=32, help='dimension of fcn')\n",
    "parser.add_argument('--moving_avg', type=int, default=25, help='window size of moving average')\n",
    "parser.add_argument('--factor', type=int, default=1, help='attn factor')\n",
    "parser.add_argument('--distil', action='store_false',\n",
    "                    help='whether to use distilling in encoder, using this argument means not using distilling',\n",
    "                    default=True)\n",
    "parser.add_argument('--dropout', type=float, default=0.1, help='dropout')\n",
    "parser.add_argument('--embed', type=str, default='timeF',\n",
    "                    help='time features encoding, options:[timeF, fixed, learned]')\n",
    "parser.add_argument('--activation', type=str, default='gelu', help='activation')\n",
    "parser.add_argument('--output_attention', action='store_true', help='whether to output attention in ecoder')\n",
    "\n",
    "# optimization\n",
    "parser.add_argument('--num_workers', type=int, default=0, help='data loader num workers')\n",
    "parser.add_argument('--itr', type=int, default=1, help='experiments times')\n",
    "parser.add_argument('--train_epochs', type=int, default=20, help='train epochs')\n",
    "parser.add_argument('--batch_size', type=int, default=32, help='batch size of train input data')\n",
    "parser.add_argument('--patience', type=int, default=3, help='early stopping patience')\n",
    "parser.add_argument('--learning_rate', type=float, default=0.0001, help='optimizer learning rate')\n",
    "parser.add_argument('--des', type=str, default='test', help='exp description')\n",
    "parser.add_argument('--loss', type=str, default='MSE', help='loss function')\n",
    "parser.add_argument('--lradj', type=str, default='type1', help='adjust learning rate')\n",
    "parser.add_argument('--use_amp', action='store_true', help='use automatic mixed precision training', default=False)\n",
    "\n",
    "# GPU\n",
    "parser.add_argument('--use_gpu', type=bool, default=False, help='use gpu')\n",
    "parser.add_argument('--gpu', type=int, default=0, help='gpu')\n",
    "parser.add_argument('--use_multi_gpu', action='store_true', help='use multiple gpus', default=False)\n",
    "parser.add_argument('--devices', type=str, default='0,1,2,3', help='device ids of multile gpus')\n",
    "\n",
    "# de-stationary projector params\n",
    "parser.add_argument('--p_hidden_dims', type=int, nargs='+', default=[128, 128], help='hidden layer dimensions of projector (List)')\n",
    "parser.add_argument('--p_hidden_layers', type=int, default=2, help='number of hidden layers in projector')\n",
    "\n",
    "# PatchTST\n",
    "parser.add_argument('--head_dropout', type=float, default=0.0, help='head dropout')\n",
    "parser.add_argument('--patch_len', type=int, default=16, help='patch length')\n",
    "parser.add_argument('--stride', type=int, default=8, help='stride')\n",
    "\n",
    "args = parser.parse_args(args=[])\n",
    "args.use_gpu = True if torch.cuda.is_available() and args.use_gpu else False\n",
    "args.seq_len = 20\n",
    "args.pred_len = 0\n",
    "args.enc_in=5\n",
    "args.num_class=3"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 38,
   "metadata": {},
   "outputs": [],
   "source": [
    "import torch\n",
    "from torch import nn\n",
    "\n",
    "import torch.nn.functional as F\n",
    "\n",
    "class ChebyshevBlock(nn.Module):\n",
    "    def __init__(self, configs):\n",
    "        super().__init__()\n",
    "\n",
    "        self.conv2 = nn.Sequential(\n",
    "            nn.Conv2d(in_channels=2 * configs.d_model, out_channels=configs.d_model, kernel_size=1, padding=0),\n",
    "        )\n",
    "        self.conv = nn.Sequential(\n",
    "            Inception_Block_V1(configs.d_model, configs.d_ff,\n",
    "                               num_kernels=configs.num_kernels),\n",
    "            nn.GELU(),\n",
    "            Inception_Block_V1(configs.d_ff, configs.d_model,\n",
    "                               num_kernels=configs.num_kernels)\n",
    "        )\n",
    "        self.configs = configs\n",
    "        self.device = 'gpu' if self.configs.use_gpu else 'cpu'\n",
    "        # chebyshev 项数 degree\n",
    "        # self.degree = self.seq_len - 1\n",
    "        self.degree = 5 - 1\n",
    "\n",
    "    def forward(self, x):\n",
    "        # chebyshev\n",
    "        x_np = x.cpu().detach().numpy()\n",
    "        chaby = [chebyshev_coefficients(x_np[i, :, :], self.degree) for i in range(x.size(0))]\n",
    "        # chaby = torch.Tensor(chaby).unsqueeze(dim=-1).to(x_enc.device)\n",
    "\n",
    "        B, T, N = x.size()\n",
    "        res = []\n",
    "\n",
    "        for i in range(self.degree + 1):\n",
    "            out = x.reshape(B, T, 1, N).permute(0, 3, 1, 2).contiguous()\n",
    "            out = self.conv(out)\n",
    "            # reshape back\n",
    "            out = out.permute(0, 2, 3, 1).reshape(B, -1, N)\n",
    "            res.append(out)\n",
    "        # for i in range(self.degree + 1):\n",
    "        #     out = x.reshape(B, T, 1, N).permute(0, 3, 1, 2).contiguous()\n",
    "        #     out1 = self.conv(out)\n",
    "        #     outFT = self.convFT(out)\n",
    "        #     out = torch.cat((out1, outFT), dim=1)\n",
    "        #     out = self.conv2(out)\n",
    "        #     # reshape back\n",
    "        #     out = out.permute(0, 2, 3, 1).reshape(B, -1, N)\n",
    "        #     res.append(out)\n",
    "        res = torch.stack(res, dim=-1)\n",
    "        period_weight = F.softmax(torch.tensor(chaby).to(self.device), dim=1)\n",
    "\n",
    "        period_weight = period_weight.unsqueeze(\n",
    "            1).unsqueeze(1).repeat(1, T, N, 1)\n",
    "        res = torch.sum(res * period_weight, -1)\n",
    "        # residual connection\n",
    "        res = res + x\n",
    "        return res\n",
    "\n",
    "class Model(nn.Module):\n",
    "    def __init__(self, configs):\n",
    "        super().__init__()\n",
    "\n",
    "\n",
    "        self.layer = configs.e_layers\n",
    "        self.task_name = configs.task_name\n",
    "        self.seq_len = configs.seq_len\n",
    "        self.label_len = configs.label_len\n",
    "        self.pred_len = configs.pred_len\n",
    "\n",
    "        self.model = nn.ModuleList([ChebyshevBlock(configs)\n",
    "                                   for _ in range(configs.e_layers)])\n",
    "        self.enc_embedding = DataEmbedding(configs.enc_in, configs.d_model, configs.embed, configs.freq,\n",
    "                                           configs.dropout)\n",
    "        self.layer_norm = nn.LayerNorm(configs.d_model)\n",
    "\n",
    "        if self.task_name == 'long_term_forecast' or self.task_name == 'short_term_forecast':\n",
    "            self.predict_linear = nn.Linear(\n",
    "                self.seq_len, self.pred_len + self.seq_len)\n",
    "            self.projection = nn.Linear(\n",
    "                configs.d_model, configs.c_out, bias=True)\n",
    "        if self.task_name == 'imputation' or self.task_name == 'anomaly_detection':\n",
    "            self.projection = nn.Linear(\n",
    "                configs.d_model, configs.c_out, bias=True)\n",
    "        if self.task_name == 'classification':\n",
    "            self.act = F.gelu\n",
    "            self.dropout = nn.Dropout(configs.dropout)\n",
    "            self.projection = nn.Linear(\n",
    "                configs.d_model * configs.seq_len, configs.num_class)\n",
    "\n",
    "    def forecast(self, x_enc, x_mark_enc, x_dec, x_mark_dec):\n",
    "        # 归一化\n",
    "        means = x_enc.mean(1, keepdim=True).detach()\n",
    "        x_enc = x_enc - means\n",
    "        stdev = torch.sqrt(\n",
    "            torch.var(x_enc, dim=1, keepdim=True, unbiased=False) + 1e-5)\n",
    "        x_enc /= stdev\n",
    "\n",
    "        enc_out = self.enc_embedding(x_enc, x_mark_enc)  # [B,T,C]\n",
    "        enc_out = self.predict_linear(enc_out.permute(0, 2, 1)).permute(\n",
    "            0, 2, 1)\n",
    "\n",
    "        for i in range(self.layer):\n",
    "            enc_out = self.layer_norm(self.model[i](enc_out))\n",
    "\n",
    "        # porject back\n",
    "        dec_out = self.projection(enc_out)\n",
    "\n",
    "        # De-Normalization from Non-stationary Transformer\n",
    "        dec_out = dec_out * \\\n",
    "            (stdev[:, 0, :].unsqueeze(1).repeat(\n",
    "                1, self.pred_len + self.seq_len, 1))\n",
    "        dec_out = dec_out + \\\n",
    "            (means[:, 0, :].unsqueeze(1).repeat(\n",
    "                1, self.pred_len + self.seq_len, 1))\n",
    "\n",
    "        return dec_out\n",
    "    def imputation(self, x_enc, x_mark_enc, x_dec, x_mark_dec, mask):\n",
    "        # Normalization from Non-stationary Transformer\n",
    "        means = torch.sum(x_enc, dim=1) / torch.sum(mask == 1, dim=1)\n",
    "        means = means.unsqueeze(1).detach()\n",
    "        x_enc = x_enc - means\n",
    "        x_enc = x_enc.masked_fill(mask == 0, 0)\n",
    "        stdev = torch.sqrt(torch.sum(x_enc * x_enc, dim=1) /\n",
    "                           torch.sum(mask == 1, dim=1) + 1e-5)\n",
    "        stdev = stdev.unsqueeze(1).detach()\n",
    "        x_enc /= stdev\n",
    "\n",
    "        # embedding\n",
    "        enc_out = self.enc_embedding(x_enc, x_mark_enc)  # [B,T,C]\n",
    "        # TimesNet\n",
    "        for i in range(self.layer):\n",
    "            enc_out = self.layer_norm(self.model[i](enc_out))\n",
    "        # porject back\n",
    "        dec_out = self.projection(enc_out)\n",
    "\n",
    "        # De-Normalization from Non-stationary Transformer\n",
    "        dec_out = dec_out * \\\n",
    "            (stdev[:, 0, :].unsqueeze(1).repeat(\n",
    "                1, self.pred_len + self.seq_len, 1))\n",
    "        dec_out = dec_out + \\\n",
    "            (means[:, 0, :].unsqueeze(1).repeat(\n",
    "                1, self.pred_len + self.seq_len, 1))\n",
    "        return dec_out\n",
    "\n",
    "    def anomaly_detection(self, x_enc):\n",
    "        # Normalization from Non-stationary Transformer\n",
    "        means = x_enc.mean(1, keepdim=True).detach()\n",
    "        x_enc = x_enc - means\n",
    "        stdev = torch.sqrt(\n",
    "            torch.var(x_enc, dim=1, keepdim=True, unbiased=False) + 1e-5)\n",
    "        x_enc /= stdev\n",
    "\n",
    "        # embedding\n",
    "        enc_out = self.enc_embedding(x_enc, None)  # [B,T,C]\n",
    "        # TimesNet\n",
    "        for i in range(self.layer):\n",
    "            enc_out = self.layer_norm(self.model[i](enc_out))\n",
    "        # porject back\n",
    "        dec_out = self.projection(enc_out)\n",
    "\n",
    "        # De-Normalization from Non-stationary Transformer\n",
    "        dec_out = dec_out * \\\n",
    "            (stdev[:, 0, :].unsqueeze(1).repeat(\n",
    "                1, self.pred_len + self.seq_len, 1))\n",
    "        dec_out = dec_out + \\\n",
    "            (means[:, 0, :].unsqueeze(1).repeat(\n",
    "                1, self.pred_len + self.seq_len, 1))\n",
    "        return dec_out\n",
    "\n",
    "    def classification(self, x_enc, x_mark_enc):\n",
    "        # embedding\n",
    "        enc_out = self.enc_embedding(x_enc, None)  # [B,T,C]\n",
    "        # TimesNet\n",
    "        for i in range(self.layer):\n",
    "            enc_out = self.layer_norm(self.model[i](enc_out))\n",
    "\n",
    "        # Output\n",
    "        # the output transformer encoder/decoder embeddings don't include non-linearity\n",
    "        output = self.act(enc_out)\n",
    "        output = self.dropout(output)\n",
    "        # zero-out padding embeddings\n",
    "        # (batch_size, seq_length * d_model)\n",
    "        output = output.reshape(output.shape[0], -1)\n",
    "        output = self.projection(output)  # (batch_size, num_classes)\n",
    "        return output\n",
    "\n",
    "    def forward(self, x_enc, x_mark_enc=None, x_dec=None, x_mark_dec=None, mask=None):\n",
    "        if self.task_name == 'long_term_forecast' or self.task_name == 'short_term_forecast':\n",
    "            dec_out = self.forecast(x_enc, x_mark_enc, x_dec, x_mark_dec)\n",
    "            return dec_out[:, -self.pred_len:, :]  # [B, L, D]\n",
    "        if self.task_name == 'imputation':\n",
    "            dec_out = self.imputation(\n",
    "                x_enc, x_mark_enc, x_dec, x_mark_dec, mask)\n",
    "            return dec_out  # [B, L, D]\n",
    "        if self.task_name == 'anomaly_detection':\n",
    "            dec_out = self.anomaly_detection(x_enc)\n",
    "            return dec_out  # [B, L, D]\n",
    "        if self.task_name == 'classification':\n",
    "            dec_out = self.classification(x_enc, x_mark_enc)\n",
    "            return dec_out  # [B, N]\n",
    "        return None\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 39,
   "metadata": {},
   "outputs": [],
   "source": [
    "class DDQN(object):\n",
    "    def __init__(self, input_size=10, seq_len = 20, learning_rate=0.01, reward_decay=0.9, e_greedy=0.9, batch_size=32, e_greedy_increment=None, attn_weight=0.1):\n",
    "        self.device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n",
    "        self.input_size = input_size\n",
    "        self.seq_len = seq_len\n",
    "        self.lr = learning_rate\n",
    "        self.gamma = torch.tensor(reward_decay, dtype=torch.float)\n",
    "        self.batch_size = batch_size\n",
    "        self.n_actions = 3\n",
    "        self.learn_step_counter = 0\n",
    "        self.memory_counter = 0\n",
    "        self.memory = np.zeros((MEMORY_CAPACITY, seq_len * input_size * 2 + 2))\n",
    "        self.state_loss = np.zeros((MEMORY_CAPACITY, 1))\n",
    "\n",
    "        self.act_net = Model(args).to(self.device)\n",
    "        self.tgt_net = Model(args).to(self.device)\n",
    "        self.optimizer = optim.Adam(self.act_net.parameters(), lr=self.lr)\n",
    "        self.tgt_optimizer = optim.Adam(self.tgt_net.parameters(), lr=self.lr)\n",
    "        self.tgt_actions = torch.zeros(TARGET_REPLACE_ITER, requires_grad=True).view(-1,1)\n",
    "        self.loss = []\n",
    "        self.EPS_START = e_greedy\n",
    "        self.EPS_END = 0.05\n",
    "        self.EPS_DECAY = 200\n",
    "        self.steps_done = 0\n",
    "\n",
    "    def epsilon_greedy_choose_action(self, observation):\n",
    "        sample = random.random()\n",
    "        eps_threshold = self.EPS_END + (self.EPS_START - self.EPS_END) * math.exp(-1. * self.steps_done / self.EPS_DECAY)\n",
    "        self.steps_done += 1\n",
    "        if sample > eps_threshold:\n",
    "            action = self.choose_action(observation)\n",
    "        else:\n",
    "            action = np.random.randint(0, self.n_actions)\n",
    "        return action\n",
    "\n",
    "\n",
    "    def choose_action(self, observation):\n",
    "        observation = observation.reshape(1, self.seq_len, self.input_size)\n",
    "        observation = torch.tensor(observation, dtype=torch.float32).to(self.device)\n",
    "        with torch.no_grad():\n",
    "            actions_value = self.act_net(observation)\n",
    "            action = torch.argmax(actions_value)\n",
    "        return action\n",
    "\n",
    "    def store_transition(self, s, a, r, s_):\n",
    "        transition = np.hstack((s, [a, r], s_))\n",
    "        index = self.memory_counter % MEMORY_CAPACITY\n",
    "        self.memory[index, :] = transition\n",
    "        self.memory_counter += 1\n",
    "\n",
    "    def reset_memory(self):\n",
    "        self.memory = np.zeros((MEMORY_CAPACITY, self.seq_len * self.input_size * 2 + 2))\n",
    "\n",
    "    def learn_tgt(self, tgt_return):\n",
    "        pass\n",
    "\n",
    "    def learn(self, batch_size):\n",
    "        self.act_net.train()\n",
    "        if self.learn_step_counter % TARGET_REPLACE_ITER==0:\n",
    "            self.tgt_net.load_state_dict(self.act_net.state_dict())\n",
    "        self.learn_step_counter += 1\n",
    "\n",
    "        self.batch_size = batch_size\n",
    "        # sample batch transitions\n",
    "        sample_index = np.random.choice(MEMORY_CAPACITY, self.batch_size)\n",
    "        batch_memory = self.memory[sample_index, :]\n",
    "\n",
    "        temp = batch_memory[:, :self.seq_len * self.input_size]\n",
    "        s = torch.tensor(temp.reshape(self.batch_size, self.seq_len, self.input_size), dtype=torch.float32).to(self.device)\n",
    "        a = torch.tensor(batch_memory[:, self.seq_len * self.input_size]).long().to(self.device)\n",
    "        r = torch.tensor(batch_memory[:, self.seq_len * self.input_size + 1], dtype=torch.float32).to(self.device)\n",
    "        temp = batch_memory[:, -self.seq_len * self.input_size:]\n",
    "        s_ = torch.tensor(temp.reshape(self.batch_size, self.seq_len, self.input_size), dtype=torch.float32).to(self.device)\n",
    "\n",
    "        q_eval = self.act_net(s, batch_size)\n",
    "        with torch.no_grad():\n",
    "            Q_B = self.tgt_net(s_, batch_size)\n",
    "            Q_A = self.act_net(s_, batch_size)\n",
    "        q_target = q_eval.clone()\n",
    "        batch_index = np.arange(self.batch_size, dtype=np.int32)\n",
    "        _, Q_A_max_index = torch.max(Q_A, dim=1)\n",
    "\n",
    "        q_target[batch_index, a] = r + self.gamma * Q_B[batch_index, Q_A_max_index]\n",
    "        q_target.detach_()\n",
    "        self.optimizer.zero_grad()\n",
    "        loss = nn.MSELoss()(q_eval, q_target)\n",
    "        loss.backward()\n",
    "        self.optimizer.step()\n",
    "\n",
    "    def training(self, trainingEnv, max_round):\n",
    "        self.is_train = True\n",
    "        self.training_SR = []   # each round sharpe ratio\n",
    "        self.training_Profit = []\n",
    "        count_learn=0\n",
    "        self.training_loss = []\n",
    "        trainingEnv.init_market_data()\n",
    "        self.scoreList = [[0 for col in range(max_round)] for row in range(4)]\n",
    "        total_reward = []\n",
    "        min_epoch = 10\n",
    "        total_reward.append(0.0)\n",
    "        for episode in range(max_round):\n",
    "            step = 0\n",
    "            self.batch_size=350\n",
    "            train_interval = 10\n",
    "            self.reset_memory()\n",
    "            startingPoint = random.randrange(200)\n",
    "            observation = trainingEnv.reset(startingPoint)\n",
    "            rewards = []\n",
    "            while True:\n",
    "                action = self.epsilon_greedy_choose_action(observation)\n",
    "                # print(action)\n",
    "                observation_, reward, done = trainingEnv.step(action)\n",
    "                self.store_transition(observation, action, reward, observation_)\n",
    "                if step and (step > 100) and (step % train_interval == 0):\n",
    "                    count_learn+=1\n",
    "                    if count_learn%10==0:\n",
    "                        self.batch_size+=40\n",
    "                    self.learn(self.batch_size)\n",
    "                observation = observation_\n",
    "                # print(observation)\n",
    "                if done:\n",
    "                    break\n",
    "                step += 1\n",
    "                rewards.append(reward)\n",
    "                b=np.cumsum(np.array(rewards))\n",
    "            total_reward.append((b[-1]))\n",
    "            print('episode', episode+1,total_reward[-1] )\n",
    "            # Compute the expected return\n",
    "            expectedReturn = trainingEnv.account['Returns'].mean()\n",
    "\n",
    "            # Compute the returns volatility\n",
    "            volatility = trainingEnv.account['Returns'].std()\n",
    "\n",
    "            # Compute the Sharpe Ratio (252 trading days in 1 year)\n",
    "            if expectedReturn != 0 and volatility != 0:\n",
    "                sharpeRatio = np.sqrt(252) * (expectedReturn)/volatility\n",
    "            else:\n",
    "                sharpeRatio = 0\n",
    "            self.training_SR.append(sharpeRatio)\n",
    "            self.training_Profit.append(trainingEnv.profit_rate_account[-1])\n",
    "\n",
    "            print('----------------')\n",
    "            try:\n",
    "                print('epoch:%d, total_profit:%.3f, sharpeRatio:%.3f, win rate:%.2f' % (episode+1, trainingEnv.profit_rate_account[-1],sharpeRatio, trainingEnv.winning_trades/trainingEnv.total_trades))\n",
    "            except:\n",
    "                print('error')\n",
    "            if (episode+1) % 5 == 0:\n",
    "                torch.save(self.act_net.state_dict(), './result/model/DDQN/DDQN{}.pth'.format(episode+1))\n",
    "        torch.save(self.act_net.state_dict(), './result/model/DDQN/DDQN.pth')\n",
    "        print('finished', total_reward )\n",
    "        print('training_SR:',self.training_SR)\n",
    "        print('training_Profit:',self.training_Profit)\n",
    "        print('mean_SR:%.3f' % np.mean(self.training_SR))\n",
    "        train_reward_DDQN = pd.DataFrame({'reward':total_reward})\n",
    "        train_reward_DDQN.to_csv(r\"./result/train/DDQN/train_reward_DDQN.csv\",sep=',')\n",
    "        train_account_DDQN = pd.DataFrame(trainingEnv.account)\n",
    "        train_account_DDQN.to_csv(r\"./result/train/DDQN/train_account_DDQN.csv\",sep=',')\n",
    "        plt.rcParams['figure.figsize'] = [7, 3]\n",
    "        plt.plot(total_reward)\n",
    "        plt.savefig(\"./result/train/DDQN/DDQN.png\",bbox_inches='tight')\n",
    "        foo_fig = plt.gcf() # 'get current figure'\n",
    "        foo_fig.savefig(r'./result/train/DDQN/DDQN.eps', format='eps', dpi=300,bbox_inches='tight')\n",
    "        plt.show()\n",
    "        print('finished' )\n",
    "        return trainingEnv\n",
    "\n",
    "    def testing(self, testingEnv):\n",
    "        self.is_train = False\n",
    "        observation = testingEnv.reset()\n",
    "        step=0\n",
    "        reward_test = []\n",
    "        action_test = []\n",
    "        while True:\n",
    "            action = self.choose_action(observation)\n",
    "            observation_, reward, done = testingEnv.step(action)\n",
    "            action_test.append(action)\n",
    "            observation = observation_\n",
    "            reward_test.append(reward)\n",
    "            if done:\n",
    "                break\n",
    "            step += 1\n",
    "        print('test finished', np.cumsum(np.array(reward_test)))\n",
    "        test_account_DDQN = pd.DataFrame(testingEnv.account)\n",
    "        test_account_DDQN.to_csv(r\"./result/test/DDQN/test_account_DDQN.csv\",sep=',')\n",
    "        plt.rcParams['figure.figsize'] = [7, 3]\n",
    "        plt.plot(np.cumsum(np.array(reward_test)))\n",
    "        print('test finished', np.cumsum(np.array(reward_test))[-1],len(np.cumsum(np.array(reward_test))),np.cumsum(np.array(reward_test))[-1]/len(np.cumsum(np.array(reward_test))))\n",
    "        plt.savefig(\"./result/test/DDQN/DDQN.png\",bbox_inches='tight')\n",
    "        foo_fig = plt.gcf() # 'get current figure'\n",
    "        foo_fig.savefig(r'./result/test/DDQN/DDQN.eps', format='eps', dpi=300,bbox_inches='tight')\n",
    "        plt.show()\n",
    "        test_reward_DDQN = pd.DataFrame({'reward':np.cumsum(np.array(reward_test))})\n",
    "        test_reward_DDQN.to_csv(r\"./result/test/DDQN/test_reward_DDQN.csv\",sep=',')\n",
    "        test_step_reward_DDQN = pd.DataFrame({'reward':np.array(reward_test)})\n",
    "        test_step_reward_DDQN.to_csv(r\"./result/test/DDQN/test_step_reward_DDQN.csv\",sep=',')\n",
    "        test_action_DDQN = pd.DataFrame({'action':np.array(action_test)})\n",
    "        test_action_DDQN.to_csv(r\"./result/test/DDQN/test_action_DDQN.csv\",sep=',')\n",
    "        return testingEnv"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n",
      "/Users/ck/anaconda3/envs/time2/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3430: FutureWarning: In a future version, DataFrame.mean(axis=None) will return a scalar mean over the entire DataFrame. To retain the old behavior, use 'frame.mean(axis=0)' or just 'frame.mean()'\n",
      "  return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n"
     ]
    }
   ],
   "source": [
    "# train\n",
    "max_round = 100\n",
    "MEMORY_CAPACITY = 1000\n",
    "TARGET_REPLACE_ITER = 10\n",
    "min_epoch = 10\n",
    "\n",
    "\n",
    "trainingEnv = TradingEnv(df, train_startingDate, train_endingDate)\n",
    "\n",
    "# # DDQN\n",
    "agent = DDQN(input_size = trainingEnv.input_size, seq_len = trainingEnv.seq_len, learning_rate=0.001,reward_decay=0.9,e_greedy=0.9,batch_size=350,attn_weight=0.1)\n",
    "trainingEnv = agent.training(trainingEnv, max_round)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "class PerformanceEstimator:\n",
    "\n",
    "    def __init__(self, tradingData):\n",
    "        self.data = tradingData\n",
    "\n",
    "\n",
    "    def computePnL(self):\n",
    "        self.PnL = self.data.loc[len(self.data)-1, \"Capitals\"] - self.data.loc[0, \"Capitals\"]\n",
    "        return self.PnL\n",
    "    \n",
    "\n",
    "    def computeAnnualizedReturn(self):\n",
    "        # Compute the cumulative return over the entire trading horizon\n",
    "        cumulativeReturn = self.data['Returns'].cumsum()\n",
    "        cumulativeReturn = cumulativeReturn.iloc[-1]\n",
    "        \n",
    "\n",
    "#         timeElapsed = self.data.iloc[-1]['Date'] - self.data.loc[0, 'Date']\n",
    "#         timeElapsed = timeElapsed.days\n",
    "        \n",
    "        timeElapsed = 555\n",
    "\n",
    "        # Compute the Annualized Return\n",
    "        if(cumulativeReturn > -1):\n",
    "            self.annualizedReturn = 100 * (((1 + cumulativeReturn) ** (365/timeElapsed)) - 1)\n",
    "        else:\n",
    "            self.annualizedReturn = -100\n",
    "        return self.annualizedReturn\n",
    "    \n",
    "    \n",
    "    def computeAnnualizedVolatility(self):\n",
    "        \n",
    "        # Compute the Annualized Volatility (252 trading days in 1 trading year)\n",
    "        self.annualizedVolatily = 100 * np.sqrt(252) * self.data['Returns'].std()\n",
    "        return self.annualizedVolatily\n",
    "    \n",
    "    \n",
    "    def computeSharpeRatio(self, riskFreeRate=0):\n",
    "        \n",
    "        # Compute the expected return\n",
    "        expectedReturn = self.data['Returns'].mean()\n",
    "        \n",
    "        # Compute the returns volatility\n",
    "        volatility = self.data['Returns'].std()\n",
    "        \n",
    "        # Compute the Sharpe Ratio (252 trading days in 1 year)\n",
    "        if expectedReturn != 0 and volatility != 0:\n",
    "            self.sharpeRatio = np.sqrt(252) * (expectedReturn - riskFreeRate)/volatility\n",
    "        else:\n",
    "            self.sharpeRatio = 0\n",
    "        return self.sharpeRatio\n",
    "    \n",
    "    \n",
    "    def computeSortinoRatio(self, riskFreeRate=0):\n",
    "        \n",
    "        # Compute the expected return\n",
    "        expectedReturn = np.mean(self.data['Returns'])\n",
    "        \n",
    "        # Compute the negative returns volatility\n",
    "        negativeReturns = [returns for returns in self.data['Returns'] if returns < 0]\n",
    "        volatility = np.std(negativeReturns)\n",
    "        \n",
    "        # Compute the Sortino Ratio (252 trading days in 1 year)\n",
    "        if expectedReturn != 0 and volatility != 0:\n",
    "            self.sortinoRatio = np.sqrt(252) * (expectedReturn - riskFreeRate)/volatility\n",
    "        else:\n",
    "            self.sortinoRatio = 0\n",
    "        return self.sortinoRatio\n",
    "    \n",
    "    \n",
    "    def computeMaxDrawdown(self, plotting=False):\n",
    "\n",
    "        # Compute both the Maximum Drawdown and Maximum Drawdown Duration\n",
    "        capital = self.data['Capitals'].values\n",
    "        through = np.argmax(np.maximum.accumulate(capital) - capital)\n",
    "        if through != 0:\n",
    "            peak = np.argmax(capital[:through])\n",
    "            self.maxDD = 100 * (capital[peak] - capital[through])/capital[peak]\n",
    "            self.maxDDD = through - peak\n",
    "        else:\n",
    "            self.maxDD = 0\n",
    "            self.maxDDD = 0\n",
    "            return self.maxDD, self.maxDDD\n",
    "\n",
    "        # Plotting of the Maximum Drawdown if required\n",
    "        if plotting:\n",
    "            plt.figure(figsize=(10, 4))\n",
    "            plt.plot(self.data['Capitals'], lw=2, color='Blue')\n",
    "            plt.plot([self.data.iloc[[peak]].index, self.data.iloc[[through]].index],\n",
    "                     [capital[peak], capital[through]], 'o', color='Red', markersize=5)\n",
    "            plt.xlabel('Time')\n",
    "            plt.ylabel('Price')\n",
    "            plt.savefig(''.join(['Figures/', 'MaximumDrawDown', '.png']))\n",
    "            #plt.show()\n",
    "\n",
    "        # Return of the results\n",
    "        return self.maxDD, self.maxDDD\n",
    "    \n",
    "\n",
    "    def computeProfitability(self):\n",
    "        \n",
    "        # Initialization of some variables\n",
    "        good = 0\n",
    "        bad = 0\n",
    "        profit = 0\n",
    "        loss = 0\n",
    "        index = next((i for i in range(len(self.data.index)) if self.data['Action'][i] != 0), None)\n",
    "        if index == None:\n",
    "            self.profitability = 0\n",
    "            self.averageProfitLossRatio = 0\n",
    "            return self.profitability, self.averageProfitLossRatio\n",
    "        money = self.data['Capitals'][index]\n",
    "\n",
    "        # Monitor the success of each trade over the entire trading horizon\n",
    "        for i in range(index+1, len(self.data.index)):\n",
    "            if(self.data['Action'][i] == 2):\n",
    "                delta = self.data['Capitals'][i] - money\n",
    "                money = self.data['Capitals'][i]\n",
    "                if(delta >= 0):\n",
    "                    good += 1\n",
    "                    profit += delta\n",
    "                else:\n",
    "                    bad += 1\n",
    "                    loss -= delta\n",
    "\n",
    "\n",
    "        # Special case of the termination trade\n",
    "        delta = self.data.iloc[-1]['Capitals'] - money\n",
    "        if(delta >= 0):\n",
    "            good += 1\n",
    "            profit += delta\n",
    "        else:\n",
    "            bad += 1\n",
    "            loss -= delta\n",
    "\n",
    "        # Compute the Profitability\n",
    "        self.profitability = 100 * good/(good + bad)\n",
    "         \n",
    "        # Compute the ratio average Profit/Loss  \n",
    "        if(good != 0):\n",
    "            profit /= good\n",
    "        if(bad != 0):\n",
    "            loss /= bad\n",
    "        if(loss != 0):\n",
    "            self.averageProfitLossRatio = profit/loss\n",
    "        else:\n",
    "            self.averageProfitLossRatio = float('Inf')\n",
    "\n",
    "        return self.profitability, self.averageProfitLossRatio\n",
    "        \n",
    "\n",
    "    def computeSkewness(self):\n",
    "        \n",
    "        # Compute the Skewness of the returns\n",
    "        self.skewness = self.data[\"Returns\"].skew()\n",
    "        return self.skewness\n",
    "        \n",
    "    \n",
    "    def computePerformance(self):\n",
    "    \n",
    "        # Compute the entire set of performance indicators\n",
    "        self.computePnL()\n",
    "        self.computeAnnualizedReturn()\n",
    "        self.computeAnnualizedVolatility()\n",
    "        self.computeProfitability()\n",
    "        self.computeSharpeRatio()\n",
    "        self.computeSortinoRatio()\n",
    "        self.computeMaxDrawdown()\n",
    "        self.computeSkewness()\n",
    "\n",
    "        # Generate the performance table\n",
    "        self.performanceTable = [[\"Profit & Loss (P&L)\", \"{0:.0f}\".format(self.PnL)], \n",
    "                                 [\"Annualized Return\", \"{0:.2f}\".format(self.annualizedReturn) + '%'],\n",
    "                                 [\"Annualized Volatility\", \"{0:.2f}\".format(self.annualizedVolatily) + '%'],\n",
    "                                 [\"Sharpe Ratio\", \"{0:.3f}\".format(self.sharpeRatio)],\n",
    "                                 [\"Sortino Ratio\", \"{0:.3f}\".format(self.sortinoRatio)],\n",
    "                                 [\"Maximum Drawdown\", \"{0:.2f}\".format(self.maxDD) + '%'],\n",
    "                                 [\"Maximum Drawdown Duration\", \"{0:.0f}\".format(self.maxDDD) + ' days'],\n",
    "                                 [\"Profitability\", \"{0:.2f}\".format(self.profitability) + '%'],\n",
    "                                 [\"Ratio Average Profit/Loss\", \"{0:.3f}\".format(self.averageProfitLossRatio)],\n",
    "                                 [\"Skewness\", \"{0:.3f}\".format(self.skewness)]]\n",
    "        \n",
    "        return self.performanceTable\n",
    "\n",
    "\n",
    "    def displayPerformance(self, name):\n",
    "        \n",
    "        # Generation of the performance table\n",
    "        self.computePerformance()\n",
    "        \n",
    "        # Display the table in the console (Tabulate for the beauty of the print operation)\n",
    "        headers = [\"Performance Indicator\", name]\n",
    "        tabulation = tabulate(self.performanceTable, headers, tablefmt=\"fancy_grid\", stralign=\"center\")\n",
    "        print(tabulation)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 34,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Visualizer:\n",
    "    def draw_SR(self, lsttdqn_sr, dqn_sr, file_name):\n",
    "        plt.clf()\n",
    "        plt.plot(dqn_sr, label = 'DQN')\n",
    "        plt.plot(lsttdqn_sr, label = 'E-DQN')\n",
    "        plt.xlabel('Training Episode')\n",
    "        # 设置纵轴标签 \n",
    "        plt.ylabel('Sharpe Ratio')\n",
    "        plt.legend()\n",
    "        plt.savefig(''.join(['Figures/', file_name, '_comparing_training_SR', '.eps']), format='eps', dpi=1000,bbox_inches='tight')\n",
    "        plt.show()\n",
    "        \n",
    "\n",
    "    def draw_final(self,  DDQN_test_account, save_path):\n",
    "        plt.clf()\n",
    "        fig = plt.figure()\n",
    "        plt.plot( DDQN_test_account['Capitals'], label = 'DDQN')\n",
    "        plt.grid()\n",
    "        plt.xlabel('Time Step')\n",
    "        # 设置纵轴标签 \n",
    "        plt.ylabel('Capitals')\n",
    "        plt.legend()\n",
    "        plt.savefig(''.join(['Figures/DDQN/',save_path, '_comparing_four_strategies', '.eps']), format='eps', dpi=1000,bbox_inches='tight')\n",
    "        plt.show()\n",
    "        \n",
    "\n",
    "\n",
    "    def draw(self, account):\n",
    "        fig, ax1 = plt.subplots(figsize=(12, 5))\n",
    "        # ax2 = ax1.twinx()\n",
    "        \n",
    "        self.account = account\n",
    "        lns1 = ax1.plot(self.account['Close'], color='royalblue', lw=2, label = \"Price\")\n",
    "        lns2 = ax1.plot(self.account.loc[self.account['Action'] == 1.0].index, \n",
    "                 self.account['Close'][self.account['Action'] == 1.0],\n",
    "                 '^', markersize=5, color='green', label = \"Long\")\n",
    "        lns3 = ax1.plot(self.account.loc[self.account['Action'] == -1.0].index, \n",
    "                 self.account['Close'][self.account['Action'] == -1.0],\n",
    "                 'v', markersize=5, color='red', label = \"Short\")\n",
    "        lns4 = ax1.plot(self.account.loc[self.account['Action'] == 2.0].index, \n",
    "                 self.account['Close'][self.account['Action'] == 2.0],\n",
    "                 'x', markersize=5, color='black', label = \"Close\")\n",
    "        \n",
    "        ax1.set_xlabel('Time Step', fontsize = 14)\n",
    "        ax1.set_ylabel(\"Close Price\", fontsize = 14)\n",
    "        ax1.tick_params(labelsize=12)\n",
    "        lns = lns1+lns2+lns3+lns4\n",
    "        labs = [l.get_label() for l in lns]\n",
    "        ax1.legend(lns, labs,loc='upper center',ncol=4, fontsize = 14, frameon=False )\n",
    "        plt.savefig(''.join(['Figures/DDQN/', 'DJI_DDQN_Actions', '.eps']), format='eps', dpi=1000,bbox_inches='tight')\n",
    "        plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 35,
   "metadata": {},
   "outputs": [
    {
     "ename": "FileNotFoundError",
     "evalue": "[Errno 2] No such file or directory: './result/model/DDQN/DDQN55.pth'",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mFileNotFoundError\u001b[0m                         Traceback (most recent call last)",
      "Cell \u001b[0;32mIn[35], line 7\u001b[0m\n\u001b[1;32m      5\u001b[0m \u001b[38;5;66;03m#DDQN\u001b[39;00m\n\u001b[1;32m      6\u001b[0m agent \u001b[38;5;241m=\u001b[39m DDQN(input_size \u001b[38;5;241m=\u001b[39m testingEnv\u001b[38;5;241m.\u001b[39minput_size, seq_len \u001b[38;5;241m=\u001b[39m testingEnv\u001b[38;5;241m.\u001b[39mseq_len, learning_rate\u001b[38;5;241m=\u001b[39m\u001b[38;5;241m0.001\u001b[39m,reward_decay\u001b[38;5;241m=\u001b[39m\u001b[38;5;241m0.9\u001b[39m,e_greedy\u001b[38;5;241m=\u001b[39m\u001b[38;5;241m0.9\u001b[39m,batch_size\u001b[38;5;241m=\u001b[39m\u001b[38;5;241m350\u001b[39m,attn_weight\u001b[38;5;241m=\u001b[39m\u001b[38;5;241m0.1\u001b[39m)\n\u001b[0;32m----> 7\u001b[0m agent\u001b[38;5;241m.\u001b[39mact_net\u001b[38;5;241m.\u001b[39mload_state_dict(\u001b[43mtorch\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mload\u001b[49m\u001b[43m(\u001b[49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[38;5;124;43m./result/model/DDQN/DDQN55.pth\u001b[39;49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[43m)\u001b[49m)\u001b[38;5;66;03m#55-30.91%\u001b[39;00m\n\u001b[1;32m      8\u001b[0m testingEnv \u001b[38;5;241m=\u001b[39m agent\u001b[38;5;241m.\u001b[39mtesting(testingEnv)\n\u001b[1;32m     11\u001b[0m DDQN_test_account \u001b[38;5;241m=\u001b[39m testingEnv\u001b[38;5;241m.\u001b[39maccount\u001b[38;5;241m.\u001b[39mdrop(labels\u001b[38;5;241m=\u001b[39m\u001b[38;5;28mrange\u001b[39m(\u001b[38;5;241m0\u001b[39m,\u001b[38;5;241m100\u001b[39m),axis\u001b[38;5;241m=\u001b[39m\u001b[38;5;241m0\u001b[39m)\u001b[38;5;241m.\u001b[39mreset_index(drop\u001b[38;5;241m=\u001b[39m\u001b[38;5;28;01mTrue\u001b[39;00m)\n",
      "File \u001b[0;32m~/anaconda3/envs/time2/lib/python3.8/site-packages/torch/serialization.py:791\u001b[0m, in \u001b[0;36mload\u001b[0;34m(f, map_location, pickle_module, weights_only, **pickle_load_args)\u001b[0m\n\u001b[1;32m    788\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;124m'\u001b[39m\u001b[38;5;124mencoding\u001b[39m\u001b[38;5;124m'\u001b[39m \u001b[38;5;129;01mnot\u001b[39;00m \u001b[38;5;129;01min\u001b[39;00m pickle_load_args\u001b[38;5;241m.\u001b[39mkeys():\n\u001b[1;32m    789\u001b[0m     pickle_load_args[\u001b[38;5;124m'\u001b[39m\u001b[38;5;124mencoding\u001b[39m\u001b[38;5;124m'\u001b[39m] \u001b[38;5;241m=\u001b[39m \u001b[38;5;124m'\u001b[39m\u001b[38;5;124mutf-8\u001b[39m\u001b[38;5;124m'\u001b[39m\n\u001b[0;32m--> 791\u001b[0m \u001b[38;5;28;01mwith\u001b[39;00m \u001b[43m_open_file_like\u001b[49m\u001b[43m(\u001b[49m\u001b[43mf\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[38;5;124;43mrb\u001b[39;49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[43m)\u001b[49m \u001b[38;5;28;01mas\u001b[39;00m opened_file:\n\u001b[1;32m    792\u001b[0m     \u001b[38;5;28;01mif\u001b[39;00m _is_zipfile(opened_file):\n\u001b[1;32m    793\u001b[0m         \u001b[38;5;66;03m# The zipfile reader is going to advance the current file position.\u001b[39;00m\n\u001b[1;32m    794\u001b[0m         \u001b[38;5;66;03m# If we want to actually tail call to torch.jit.load, we need to\u001b[39;00m\n\u001b[1;32m    795\u001b[0m         \u001b[38;5;66;03m# reset back to the original position.\u001b[39;00m\n\u001b[1;32m    796\u001b[0m         orig_position \u001b[38;5;241m=\u001b[39m opened_file\u001b[38;5;241m.\u001b[39mtell()\n",
      "File \u001b[0;32m~/anaconda3/envs/time2/lib/python3.8/site-packages/torch/serialization.py:271\u001b[0m, in \u001b[0;36m_open_file_like\u001b[0;34m(name_or_buffer, mode)\u001b[0m\n\u001b[1;32m    269\u001b[0m \u001b[38;5;28;01mdef\u001b[39;00m \u001b[38;5;21m_open_file_like\u001b[39m(name_or_buffer, mode):\n\u001b[1;32m    270\u001b[0m     \u001b[38;5;28;01mif\u001b[39;00m _is_path(name_or_buffer):\n\u001b[0;32m--> 271\u001b[0m         \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[43m_open_file\u001b[49m\u001b[43m(\u001b[49m\u001b[43mname_or_buffer\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mmode\u001b[49m\u001b[43m)\u001b[49m\n\u001b[1;32m    272\u001b[0m     \u001b[38;5;28;01melse\u001b[39;00m:\n\u001b[1;32m    273\u001b[0m         \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;124m'\u001b[39m\u001b[38;5;124mw\u001b[39m\u001b[38;5;124m'\u001b[39m \u001b[38;5;129;01min\u001b[39;00m mode:\n",
      "File \u001b[0;32m~/anaconda3/envs/time2/lib/python3.8/site-packages/torch/serialization.py:252\u001b[0m, in \u001b[0;36m_open_file.__init__\u001b[0;34m(self, name, mode)\u001b[0m\n\u001b[1;32m    251\u001b[0m \u001b[38;5;28;01mdef\u001b[39;00m \u001b[38;5;21m__init__\u001b[39m(\u001b[38;5;28mself\u001b[39m, name, mode):\n\u001b[0;32m--> 252\u001b[0m     \u001b[38;5;28msuper\u001b[39m()\u001b[38;5;241m.\u001b[39m\u001b[38;5;21m__init__\u001b[39m(\u001b[38;5;28;43mopen\u001b[39;49m\u001b[43m(\u001b[49m\u001b[43mname\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mmode\u001b[49m\u001b[43m)\u001b[49m)\n",
      "\u001b[0;31mFileNotFoundError\u001b[0m: [Errno 2] No such file or directory: './result/model/DDQN/DDQN55.pth'"
     ]
    }
   ],
   "source": [
    "# test\n",
    "testingEnv = TradingEnv(df, test_startingDate, test_endingDate)\n",
    "testingEnv.init_market_data()\n",
    "\n",
    "#DDQN\n",
    "agent = DDQN(input_size = testingEnv.input_size, seq_len = testingEnv.seq_len, learning_rate=0.001,reward_decay=0.9,e_greedy=0.9,batch_size=350,attn_weight=0.1)\n",
    "agent.act_net.load_state_dict(torch.load('./result/model/DDQN/DDQN55.pth'))#55-30.91%\n",
    "testingEnv = agent.testing(testingEnv)\n",
    "\n",
    "\n",
    "DDQN_test_account = testingEnv.account.drop(labels=range(0,100),axis=0).reset_index(drop=True)\n",
    "drawing_pic = Visualizer()\n",
    "drawing_pic.draw(DDQN_test_account)\n",
    "drawing_pic.draw_final(DDQN_test_account, save_path='DDQN')\n",
    "analyser = PerformanceEstimator(DDQN_test_account)\n",
    "analyser.displayPerformance('DJI_DDQN')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.17"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
